//
//  ShaderManagerTests.swift
//  VectorAccelerate
//
//  Comprehensive tests for ShaderManager
//

@preconcurrency import XCTest
@preconcurrency import Metal
@testable import VectorAccelerate

final class ShaderManagerTests: XCTestCase {
    var device: MTLDevice!
    var shaderManager: ShaderManager!
    
    override func setUp() async throws {
        try await super.setUp()
        guard let device = MTLCreateSystemDefaultDevice() else {
            throw XCTSkip("Metal not available")
        }
        self.device = device
        self.shaderManager = ShaderManager(device: device)
    }
    
    override func tearDown() async throws {
        shaderManager = nil
        device = nil
        try await super.tearDown()
    }
    
    // MARK: - Initialization Tests
    
    func testInitialization() async throws {
        XCTAssertNotNil(shaderManager)
        XCTAssertEqual(shaderManager.device.name, device.name)
    }
    
    func testInitializationWithCustomDevice() async throws {
        // Test with system default device
        let manager = ShaderManager(device: device)
        XCTAssertNotNil(manager)
    }
    
    // MARK: - Shader Compilation Tests
    
    func testCompileValidShader() async throws {
        let shaderSource = """
        #include <metal_stdlib>
        using namespace metal;
        
        kernel void testKernel(device float* data [[buffer(0)]],
                              uint id [[thread_position_in_grid]]) {
            data[id] = data[id] * 2.0f;
        }
        """
        
        do {
            let library = try await shaderManager.compileLibrary(source: shaderSource)
            XCTAssertNotNil(library)
        } catch {
            XCTFail("Failed to compile valid shader: \(error)")
        }
    }
    
    func testCompileInvalidShader() async throws {
        let invalidSource = """
        This is not valid Metal shader code!
        """
        
        do {
            _ = try await shaderManager.compileLibrary(source: invalidSource)
            XCTFail("Should have thrown error for invalid shader")
        } catch {
            // Expected error
            XCTAssertTrue(error is AccelerationError)
        }
    }
    
    func testShaderCompilationCaching() async throws {
        let shaderSource = """
        #include <metal_stdlib>
        using namespace metal;
        kernel void cachedKernel() {}
        """
        
        // First compilation
        let library1 = try await shaderManager.compileLibrary(source: shaderSource)
        
        // Second compilation should return cached version
        let library2 = try await shaderManager.compileLibrary(source: shaderSource)
        
        // Both should be valid
        XCTAssertNotNil(library1)
        XCTAssertNotNil(library2)
    }
    
    // MARK: - Function Loading Tests
    
    func testLoadExistingFunction() async throws {
        let functionName = "dotProduct"
        
        do {
            let function = try await shaderManager.loadFunction(name: functionName)
            XCTAssertNotNil(function)
            XCTAssertEqual(function.name, functionName)
        } catch {
            // If embedded shaders not available, skip
            throw XCTSkip("Shader function not available: \(error)")
        }
    }
    
    func testLoadNonExistentFunction() async throws {
        let functionName = "nonExistentFunction"
        
        do {
            _ = try await shaderManager.loadFunction(name: functionName)
            XCTFail("Should have thrown error for non-existent function")
        } catch {
            // Expected error
            XCTAssertTrue(error is AccelerationError)
        }
    }
    
    func testFunctionCaching() async throws {
        let functionName = "vectorAdd"
        
        // Skip if function doesn't exist
        guard let _ = try? await shaderManager.loadFunction(name: functionName) else {
            throw XCTSkip("Test function not available")
        }
        
        // Measure first load
        let start1 = CFAbsoluteTimeGetCurrent()
        _ = try await shaderManager.loadFunction(name: functionName)
        let time1 = CFAbsoluteTimeGetCurrent() - start1
        
        // Measure cached load
        let start2 = CFAbsoluteTimeGetCurrent()
        _ = try await shaderManager.loadFunction(name: functionName)
        let time2 = CFAbsoluteTimeGetCurrent() - start2
        
        // Cached should be faster (allowing for variance)
        XCTAssertLessThan(time2, time1 * 2.0)
    }
    
    // MARK: - Pipeline State Tests
    
    func testCreatePipelineState() async throws {
        let functionName = "vectorAdd"
        
        do {
            let pipeline = try await shaderManager.createPipelineState(functionName: functionName)
            XCTAssertNotNil(pipeline)
        } catch {
            throw XCTSkip("Pipeline creation not available: \(error)")
        }
    }
    
    func testPipelineStateCaching() async throws {
        let functionName = "dotProduct"
        
        guard let _ = try? await shaderManager.createPipelineState(functionName: functionName) else {
            throw XCTSkip("Test function not available")
        }
        
        // Create pipeline state twice
        let pipeline1 = try await shaderManager.createPipelineState(functionName: functionName)
        let pipeline2 = try await shaderManager.createPipelineState(functionName: functionName)
        
        XCTAssertNotNil(pipeline1)
        XCTAssertNotNil(pipeline2)
    }
    
    func testPipelineStateWithConfiguration() async throws {
        let functionName = "matrixMultiply"
        let maxThreads = 256
        
        do {
            let pipeline = try await shaderManager.createPipelineState(
                functionName: functionName,
                constants: nil
            )
            XCTAssertNotNil(pipeline)
            XCTAssertLessThanOrEqual(pipeline.maxTotalThreadsPerThreadgroup, 1024)
        } catch {
            throw XCTSkip("Custom pipeline configuration not available: \(error)")
        }
    }
    
    // MARK: - Performance Metrics Tests
    
    func testCompilationStatistics() async throws {
        // Clear any existing stats
        shaderManager.clearStatistics()
        
        let shaderSource = """
        #include <metal_stdlib>
        using namespace metal;
        kernel void statsTestKernel() {}
        """
        
        // Compile several times
        for i in 0..<3 {
            _ = try? await shaderManager.compileShader(
                source: shaderSource + "// variant \(i)"
            )
        }
        
        let stats = shaderManager.getStatistics()
        XCTAssertGreaterThan(stats.compilationCount, 0)
        XCTAssertGreaterThan(stats.totalCompilationTime, 0)
    }
    
    func testCacheEffectiveness() async throws {
        shaderManager.clearStatistics()
        
        let functionName = "vectorAdd"
        
        // Load same function multiple times
        for _ in 0..<5 {
            _ = try? await shaderManager.loadFunction(name: functionName)
        }
        
        let stats = shaderManager.getStatistics()
        XCTAssertGreaterThan(stats.cacheHits, 0)
    }
    
    // MARK: - Specialized Shader Tests
    
    func testPrecompileCommonShaders() async throws {
        let commonFunctions = ["vectorAdd", "dotProduct", "matrixMultiply"]
        
        do {
            try await shaderManager.precompileShaders(functionNames: commonFunctions)
            
            // Verify they're cached
            for function in commonFunctions {
                let _ = try? await shaderManager.loadFunction(name: function)
            }
        } catch {
            throw XCTSkip("Precompilation not available: \(error)")
        }
    }
    
    func testSelectOptimalShader() async throws {
        let baseFunction = "matrixMultiply"
        let dataSize = 1024
        
        do {
            let optimalFunction = try await shaderManager.selectOptimalShader(
                baseFunction: baseFunction,
                parameters: ["size": dataSize]
            )
            XCTAssertNotNil(optimalFunction)
        } catch {
            throw XCTSkip("Optimal shader selection not available: \(error)")
        }
    }
    
    // MARK: - Thread Safety Tests
    
    func testConcurrentShaderCompilation() async throws {
        let iterations = 10
        
        await withTaskGroup(of: Bool.self) { group in
            for i in 0..<iterations {
                group.addTask {
                    let source = """
                    #include <metal_stdlib>
                    using namespace metal;
                    kernel void concurrentKernel\(i)() {}
                    """
                    
                    do {
                        let _ = try await self.shaderManager.compileLibrary(source: source)
                        return true
                    } catch {
                        return false
                    }
                }
            }
            
            var successCount = 0
            for await success in group {
                if success { successCount += 1 }
            }
            
            XCTAssertGreaterThan(successCount, 0)
        }
    }
    
    func testConcurrentFunctionLoading() async throws {
        let functionName = "vectorAdd"
        let iterations = 20
        
        await withTaskGroup(of: Bool.self) { group in
            for _ in 0..<iterations {
                group.addTask {
                    do {
                        let _ = try await self.shaderManager.loadFunction(name: functionName)
                        return true
                    } catch {
                        return false
                    }
                }
            }
            
            var successCount = 0
            for await success in group {
                if success { successCount += 1 }
            }
            
            // Most should succeed (allowing for some resource contention)
            XCTAssertGreaterThan(successCount, iterations / 2)
        }
    }
    
    // MARK: - Error Handling Tests
    
    func testCompilationErrorDetails() async throws {
        let invalidSource = """
        #include <metal_stdlib>
        using namespace metal;
        kernel void errorKernel(device float* data [[buffer(0)]]) {
            undefined_function(); // This will cause an error
        }
        """
        
        do {
            _ = try await shaderManager.compileLibrary(source: invalidSource)
            XCTFail("Should have thrown compilation error")
        } catch let error as AccelerationError {
            switch error {
            case .shaderCompilationFailed(let message):
                XCTAssertFalse(message.isEmpty)
            default:
                XCTFail("Wrong error type")
            }
        }
    }
    
    func testResourceExhaustion() async throws {
        // Try to create many pipeline states
        var pipelines: [MTLComputePipelineState] = []
        
        do {
            for i in 0..<100 {
                let source = """
                #include <metal_stdlib>
                using namespace metal;
                kernel void resourceTest\(i)() {}
                """
                
                if let library = try? await shaderManager.compileLibrary(source: source),
                   let function = library.makeFunction(name: "resourceTest\(i)"),
                   let pipeline = try? await shaderManager.getPipelineState(functionName: "resourceTest\(i)", library: library) {
                    pipelines.append(pipeline)
                }
            }
        } catch {
            // Resource exhaustion is acceptable
            XCTAssertTrue(true)
        }
        
        // Cleanup
        pipelines.removeAll()
    }
    
    // MARK: - Integration Tests
    
    func testEndToEndShaderExecution() async throws {
        // Create a simple shader
        let shaderSource = """
        #include <metal_stdlib>
        using namespace metal;
        
        kernel void doubleValues(device float* data [[buffer(0)]],
                                uint id [[thread_position_in_grid]]) {
            data[id] = data[id] * 2.0f;
        }
        """
        
        // Compile shader
        let library = try await shaderManager.compileLibrary(source: shaderSource)
        
        // Create pipeline
        guard let function = library.makeFunction(name: "doubleValues") else {
            XCTFail("Failed to get function")
            return
        }
        
        let pipeline = try await shaderManager.getPipelineState(functionName: "testKernel", library: library)
        
        // Create test data
        let count = 256
        var data = Array(repeating: Float(1.0), count: count)
        
        // Create buffer
        guard let buffer = device.makeBuffer(length: count * MemoryLayout<Float>.stride, options: .storageModeShared) else {
            XCTFail("Failed to create buffer")
            return
        }
        
        // Copy data to buffer
        data.withUnsafeBufferPointer { ptr in
            buffer.contents().copyMemory(from: ptr.baseAddress!, byteCount: count * MemoryLayout<Float>.stride)
        }
        
        // Execute shader
        guard let commandQueue = try? device.makeCommandQueue(),
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let encoder = commandBuffer.makeComputeCommandEncoder() else {
            XCTFail("Failed to create command encoder")
            return
        }
        
        encoder.setComputePipelineState(pipeline)
        encoder.setBuffer(buffer, offset: 0, index: 0)
        
        let threadsPerGrid = MTLSize(width: count, height: 1, depth: 1)
        let threadsPerThreadgroup = MTLSize(width: 32, height: 1, depth: 1)
        encoder.dispatchThreads(threadsPerGrid, threadsPerThreadgroup: threadsPerThreadgroup)
        
        encoder.endEncoding()
        commandBuffer.commit()
        commandBuffer.waitUntilCompleted()
        
        // Verify results
        let result = buffer.contents().bindMemory(to: Float.self, capacity: count)
        for i in 0..<count {
            XCTAssertEqual(result[i], 2.0, accuracy: 1e-5)
        }
    }
}